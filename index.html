<script>
  // ===== endpoints =====
  const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbzBmAYNv4eTLAwAZFj-MvGHJsplP2Ugen8e6hzypnIUhLE4nKBxvIhY5M9RlrBqxbX4aw/exec";
  const RESERVE_MINUTES_FALLBACK = 30;

  // ===== ui refs =====
  const nurseInput = document.getElementById('nurse');
  const nurseNote  = document.getElementById('nurseSavedNote');
  const diag       = document.getElementById('diag');
  const statusFilter = document.getElementById('statusFilter');
  const areaFilter   = document.getElementById('areaFilter');
  document.getElementById('refreshBtn').onclick = () => loadBeds();
  statusFilter.onchange = () => render();
  areaFilter.oninput    = () => render();

  // tabs already wired in your page (if you have tabs). If not, ignore.

  // ===== nurse identity =====
  document.getElementById('saveNurse').onclick = () => {
    const v = nurseInput.value.trim();
    if (!v) return;
    localStorage.setItem('bmu_nurse', v);
    nurseNote.textContent = `Saved as ${v}`;
    render();
  };
  const saved = localStorage.getItem('bmu_nurse') || "";
  if (saved) { nurseInput.value = saved; nurseNote.textContent = `Saved as ${saved}`; }

  // ===== state =====
  let beds = [];
  let reserveMinutes = RESERVE_MINUTES_FALLBACK;
  let tickTimer = null;

  // "pending overlay" cache (keeps recent reserves visible across refresh)
  const PENDING_KEY = "bmu_pending_v1";
  const STICKY_MS = 5 * 60 * 1000; // show local overlay for up to 5 minutes

  function loadPending(){
    try { return JSON.parse(localStorage.getItem(PENDING_KEY) || "{}"); } catch { return {}; }
  }
  function savePending(obj){
    localStorage.setItem(PENDING_KEY, JSON.stringify(obj));
  }
  function cleanupPending(){
    const now = Date.now();
    const p = loadPending();
    let changed = false;
    Object.keys(p).forEach(bedID => {
      if (p[bedID].until <= now) { delete p[bedID]; changed = true; }
    });
    if (changed) savePending(p);
    return p;
  }
  function setPendingReserve(bedID, nurse, timeIso){
    const p = cleanupPending();
    p[bedID] = { status:"Reserved", nurse, timeBooked: timeIso, until: Date.now() + STICKY_MS };
    savePending(p);
  }
  function clearPending(bedID){
    const p = loadPending();
    if (p[bedID]) { delete p[bedID]; savePending(p); }
  }
  function overlayPending(targetBeds){
    // overwrite the server row with the pending row if still within sticky time
    const p = cleanupPending();
    const map = Object.fromEntries(targetBeds.map((b,i)=>[String(b.bedID), i]));
    Object.entries(p).forEach(([bedID, patch])=>{
      const i = map[String(bedID)];
      if (i !== undefined) {
        targetBeds[i] = { ...targetBeds[i], ...patch };
      }
    });
    if (Object.keys(p).length) diag.textContent = `API ok (${targetBeds.length} rows) • overlaying recent updates`;
  }

  // ===== helpers =====
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function escapeAttr(s){ return escapeHtml(s).replace(/"/g,'&quot;'); }

  async function fetchJsonWithRetry(url, tries=3, delayMs=600){
    let lastErr;
    for (let i=0;i<tries;i++){
      try{
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      }catch(e){ lastErr = e; await sleep(delayMs); }
    }
    throw lastErr || new Error('fetch failed');
  }

  function pill(status){
    const s = (status||"").toLowerCase();
    if (s==="available")   return `<span class="pill pill-available">Available</span>`;
    if (s==="reserved")    return `<span class="pill pill-reserved">Reserved</span>`;
    if (s==="unavailable" || s==="booked") return `<span class="pill pill-unavailable">Unavailable</span>`;
    return status || "";
  }

  function fmtTime(iso){
    if (!iso) return "";
    const d = new Date(iso);
    return d.toLocaleString(undefined, { year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false });
  }

  function expiryFromRow(row){
    if ((row.status||"").toLowerCase()!=="reserved" || !row.timeBooked) return "";
    const start = Date.parse(row.timeBooked);
    if (isNaN(start)) return "";
    return new Date(start + (reserveMinutes*60000)).toISOString();
  }
  function countdownText(expiryIso){
    if (!expiryIso) return "";
    const end = Date.parse(expiryIso), now = Date.now(), ms = end - now;
    if (isNaN(end) || ms <= 0) return "expiring…";
    const s = Math.floor(ms/1000), m = Math.floor(s/60), r = s%60;
    return `${m}m ${r}s left`;
  }
  function restartTicker(){
    if (tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(() => {
      document.querySelectorAll('[data-expiry]').forEach(el => {
        el.textContent = countdownText(el.getAttribute('data-expiry'));
      });
    }, 1000);
  }

  // ===== load (JSON only) =====
  async function loadBeds(){
    try {
      const json = await fetchJsonWithRetry(`${WEB_APP_URL}?fn=beds&_=${Date.now()}`, 3, 600);
      if (!json || !json.ok || !Array.isArray(json.beds)) throw new Error("Bad JSON payload");
      beds = json.beds;
      reserveMinutes = json.reserveMinutes || RESERVE_MINUTES_FALLBACK;

      // overlay recent local updates so refresh doesn't "lose" a just-made reservation
      overlayPending(beds);

      diag.textContent = `API ok (${beds.length} rows)`;
      render();
      restartTicker();
    } catch (e) {
      console.error("API error:", e);
      diag.textContent = `API error: ${e.message || e}`;
      // keep whatever we were showing; don’t blank the table on a transient hiccup
    }
  }

  // ===== render =====
  function actionsForRow(row){
    // Only show Reserve when Available; otherwise blank (no "Mark Available")
    if ((row.status||"").toLowerCase()==="available") {
      return `<button onclick="reserveBed('${escapeAttr(row.bedID)}', '${escapeAttr(row.area||"")}')">Reserve 30m</button>`;
    }
    return "";
  }

  function rowStatusCell(row){
    const p = pill(row.status||"");
    const exp = expiryFromRow(row);
    if (exp) return `${p}<span class="sub" data-expiry="${escapeAttr(exp)}">${countdownText(exp)}</span>`;
    return p;
  }

  function mountTable(targetId, rows){
    const el = document.getElementById(targetId);
    if (!rows.length) { el.innerHTML = "<div class='muted'>No rows</div>"; return; }
    el.innerHTML = [
      "<table>",
      "<thead><tr><th>Bed ID</th><th>Area</th><th>Status</th><th>Nurse</th><th>Time</th><th style='width:1%'>Action</th></tr></thead>",
      "<tbody>",
      ...rows.map(r=>`
        <tr>
          <td>${escapeHtml(String(r.bedID))}</td>
          <td>${escapeHtml(r.area||"")}</td>
          <td>${rowStatusCell(r)}</td>
          <td>${escapeHtml(r.nurse||"")}</td>
          <td>${fmtTime(r.timeBooked||"")}</td>
          <td style="white-space:nowrap">${actionsForRow(r)}</td>
        </tr>
      `),
      "</tbody></table>"
    ].join("");
  }

  function render(){
    const areaQ = (areaFilter.value||"").toLowerCase();
    const statusQ = (statusFilter.value||"").toLowerCase();
    const me = (localStorage.getItem('bmu_nurse')||"").trim().toLowerCase();

    const filtered = beds.filter(b =>
      (areaQ==="" || String(b.area||"").toLowerCase().includes(areaQ)) &&
      (statusQ==="" || String(b.status||"").toLowerCase() === statusQ)
    );
    mountTable("tblOverall", filtered);

    const mine = beds.filter(b => {
      const nurse = (b.nurse||"").toLowerCase();
      const s = (b.status||"").toLowerCase();
      return me && nurse===me && (s==="reserved" || s==="unavailable");
    });
    if (document.getElementById("tblMyReserved")) {
      mountTable("tblMyReserved", mine);
    }
  }

  // ===== write (reserve only) =====
  async function callApi(payload){
    const res = await fetch(WEB_APP_URL, {
      method: "POST",
      headers: { "Content-Type": "text/plain" }, // avoid preflight
      body: JSON.stringify(payload)
    });
    const text = await res.text();
    let json; try { json = JSON.parse(text); } catch { json = { ok:false, raw:text }; }
    return { status: res.status, json };
  }

  function optimisticUpdate(bedID, patch) {
    const idx = beds.findIndex(b => String(b.bedID) === String(bedID));
    if (idx >= 0) { beds[idx] = { ...beds[idx], ...patch }; render(); }
  }

  window.reserveBed = async (bedID, area) => {
    const nurse = (localStorage.getItem('bmu_nurse')||"").trim();
    if (!nurse) { alert("Enter your Nurse name/email and click Save first."); return; }
    const nowIso = new Date().toISOString();

    // optimistic UI
    optimisticUpdate(bedID, { status: "Reserved", nurse, timeBooked: nowIso });
    // record pending overlay so a hard refresh still shows this for a few minutes
    setPendingReserve(bedID, nurse, nowIso);

    try {
      await callApi({ bedID, area, status: "reserved", nurseName: nurse, clientTime: nowIso });
      // once the server reflects it, we can clear the local pending for this bed
      // (doLoad will pull server state). We'll clear after first successful refresh.
    } finally {
      // gentle retries to refresh from JSON
      await sleep(600); await loadBeds();
      await sleep(800); await loadBeds();
      // after two refreshes, if server shows Reserved, clear pending
      const row = beds.find(b => String(b.bedID) === String(bedID));
      if (row && (row.status||"").toLowerCase()==="reserved" && (row.nurse||"")===nurse) {
        clearPending(bedID);
      }
    }
  };

  // go
  loadBeds();
</script>
